#include "dsp_lib.h"
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include "error.h"
/***********************************************
Function name: benvel

Function description: 

Parameters: 
1. rv1 (inp) - Real input vector 
2. rvo (inp) - Real output vector 
3. n (out) - transform size(number of real points) 

Return type: integer error code
***********************************************/
int dolph_chebychev(float *rv1, long inc1, float *rvo, long inco, long n, float alpha)
{
	float gamma;
	float beta;

	gamma = pow (10, alpha);
	beta = cosh (acosh (gamma / n - 1));
	
	for (k = 0; k < n; k++)

	int i;
	float *hlrvo = (float *)calloc((n), sizeof(float));
	bhlbrt(rv1, hlrvo, n);

	for (i = 0; i < n; i++)
	{
		rvo[i] = sqrt(pow(rv1[i], 2) + pow(hlrvo[i], 2));
		/*printf(" benvel vector[%d]=%f\n", i, hlrvo[i]);*/
	}	
}

int bhlbrt(float *rv1, float *rvo, long n)
{
	long i = 0, k=0, m = 0;
	float temp, *temp1;
	long *p;
	int err;

	temp1 = (float*)calloc((n*2), sizeof(float));

	err = bavfftwts(&p, 8, 0);

	for (i = 0; i < 8; i++)
	{
		printf("W[%d] = %f\n", i, ((fft_vector*)p)->cplx_arr[i].real);
		printf("W[%d] = %f\n", i, ((fft_vector*)p)->cplx_arr[i].im); 
	}
	
	bavrfftf(rv1, 1, temp1, 2, n, p);
	rearrange_fft(temp1, n);

	/*for(i = 0; i < n*2; i++)
	{
		printf("temp1[%d]=%f\n",i,temp1[i]);
	}*/
	printf("Hello1\n");
	swap_2(temp1, (n*2));
	while (m < (n*2))
	{
		temp1[k] = temp1[i] * (-1);
		i = i + 1;
		k = k + 1;
		m = m + 1;
	}
	for(i = 0; i < n*2; i++)
	{
		printf("temp1[%d]=%f\n",i,temp1[i]);
	}
	bavrffti(temp1, 2, rvo, 1, n, p);
	
/*
	free(((fft_vector*)p)->real_arr);
	free(((fft_vector*)p)->cplx_arr);
	free((fft_vector*)p); */
	return (SUCCESS);
}


void swap_2(float *in_2, int n_2)
{
	float temp;
	int i = 0;
	while(i < n_2)
	{
		temp = in_2[i];
		in_2[i] = in_2[i+1];
		in_2[i+1] = temp;
		i += 2;
	}
}



/***********************************************
Function name: bavcfftf

Function description: 
The forward complex FFT of the complex input vector is computed and stored in the complex
output vector.

Parameters: 
1. cv1 (inp) - Complex input vector
2. inc1 (inp) - Input vector increment
3. cvo (out) - Complex output vector
4. inco (inp) - Output vector increment
5. n (inp) - FFT size (number of complex points)
6. p (inp) - pointer to FFT setup previously generated by calling avfftwts

Return type: integer error code

 ***********************************************/

int bavrfftf( float *cv1, long inc1, float *cout, long inco, long n, long *p) 
{
	int incflag = 0, bufflag = 0, vecflag = 0, cflag = 0;
	float *cv2;
	float *cbuff;
	int s = 0;
	int q = 0, r = 0;
	FILE *inputFd, *outputFd;

	printf("Hello\n");
	if (cv1 != cout)
	{
		int i = 0, j = 0;
		bufflag = 1;
		cbuff = calloc (n*inc1*2, sizeof (float));
		while ( i < n*inc1*2 )
		{
			cbuff[i] = cv1[j];
			i = i + 2;
			j = j + 1;
		}
		inc1 = 2 * inc1;
	
/*		outputFd = fopen("fft_gap.txt", "w+");
		for (i = 0; i < n*2; i++)
		{
			fprintf(outputFd, "%f\n", *((float*)cbuff+i));
		}
		fclose(outputFd);
		for (i = 0; i < 16; i++)
		{
			printf("cbuff[%d]:%f\n", i, cbuff[i]);
			printf("%d\n", inc1);
		}
*/
	}
	if ((inc1 != 2))
	{
		incflag = 1;
		cv2 = calloc(n*2, sizeof(float));
		while ( q < n*2 )
		{
			if (bufflag == 1)
			{
				cv2[q] = cbuff[r];
				cv2[q+1] = cbuff[r+1];
			}
			else
			{
				cv2[q] = cv1[r];
				cv2[q+1] = cv1[r+1];
			}
			q = q+2;
			r = r+inc1;
		}
		inc1 = 2;
		printf("Hello2\n");
	}
	
	cflag = 1;
	CV_COMPLEX *pfs;
	unsigned int stage,block,j,i,iw=0;
	unsigned int pa,pb,qa,qb;
	unsigned int stride,edirts;
	CV_COMPLEX ft1a,ft1b,ft2a,ft2b,ft3a,ft3b;
	unsigned int log_n;

	log_n = log(n)/log(2);

	if (incflag == 1)
		pfs = (CV_COMPLEX *)cv2;
	else if (bufflag == 1)
		pfs = (CV_COMPLEX *)cbuff;
	else
		pfs = (CV_COMPLEX *)cv1;

	CV_COMPLEX *pfw = ((fft_vector*)p)->cplx_arr;

	/*//INIT*/
	stride = n/2;
	edirts = 1;
	/*//DIF FFT*/

	for( stage=0; stage<log_n-2; stage++ ) 
	{
		for( block=0; block<n; block+=stride*2 ) 
		{
			pa = block;
			pb = block + stride/2;
			qa = block + stride;
			qb = block + stride/2 + stride;
			iw = 0;
			for( j=0; j<stride/2; j++ ) 
			{
				/*//2bufflies/loop
					//add*/
				ft1a.real = pfs[pa+j].real + pfs[qa+j].real;
				ft1a.im = pfs[pa+j].im + pfs[qa+j].im;
				ft1b.real = pfs[pb+j].real + pfs[qb+j].real;
				ft1b.im = pfs[pb+j].im + pfs[qb+j].im;
				/*//sub*/
				ft2a.real = pfs[pa+j].real - pfs[qa+j].real;
				ft2a.im = pfs[pa+j].im - pfs[qa+j].im;
				ft2b.real = pfs[pb+j].real - pfs[qb+j].real;
				ft2b.im = pfs[pb+j].im - pfs[qb+j].im;
				pfs[pa+j] = ft1a;
				/*//store adds*/
				pfs[pb+j] = ft1b;
				/*//cmul*/
				pfs[qa+j].real = ft2a.real * pfw[iw].real -
				ft2a.im * pfw[iw].im;
				pfs[qa+j].im = ft2a.real * pfw[iw].im +
				ft2a.im * pfw[iw].real;
				/*//twiddled cmul*/
				pfs[qb+j].real = ft2b.real * pfw[iw].im +
				ft2b.im * pfw[iw].real;
				pfs[qb+j].im = -ft2b.real * pfw[iw].real +
				ft2b.im * pfw[iw].im;
				iw += edirts;
			}
		}
		stride = stride>>1;
		edirts = edirts<<1;
	}
	/*//last two stages*/
	for( j=0; j<n; j+=4 ) 
	{
		/*//upper two*/
		ft1a.real = pfs[j ].real + pfs[j+2].real;
		ft1a.im = pfs[j ].im + pfs[j+2].im;
		ft1b.real = pfs[j+1].real + pfs[j+3].real;
		ft1b.im = pfs[j+1].im + pfs[j+3].im;
		ft2a.real = ft1a.real + ft1b.real;
		ft2a.im = ft1a.im + ft1b.im;
		ft2b.real = ft1a.real - ft1b.real;
		ft2b.im = ft1a.im - ft1b.im;
		/*//lower two
			//notwiddle*/
		ft3a.real = pfs[j].real - pfs[j+2].real;
		ft3a.im = pfs[j].im - pfs[j+2].im;
		/*//twiddle*/
		ft3b.real = pfs[j+1].im - pfs[j+3].im;
		ft3b.im = -pfs[j+1].real + pfs[j+3].real;
		/*//store*/
		pfs[j ]	= ft2a;
		pfs[j+1]= ft2b;
		pfs[j+2].real = ft3a.real + ft3b.real;
		pfs[j+2].im = ft3a.im + ft3b.im;
		pfs[j+3].real = ft3a.real - ft3b.real;
		pfs[j+3].im = ft3a.im - ft3b.im;

	}


	if ((incflag == 1) && (bufflag == 0))
	{
		q = 0;
		r = 0;
		while (r < n*2)
		{
			cv1[q] = cv2[r];
			cv1[q+1] = cv2[r+1];

			q = q + inco;
			r = r + 2;
		}
	}
	else if ((incflag == 1) && (bufflag == 1))
	{
		q = 0;
		r = 0;
		while (r < n*2)
		{
			cout[q] = cv2[r];
			cout[q+1] = cv2[r+1];

			q = q + inco;
			r = r + 2;
		}
	}
	else if ((incflag == 0) && (bufflag == 1))
	{
		q = 0;
		r = 0;
		while (r < n*2)
		{
			cout[q] = cbuff[r];
			cout[q+1] = cbuff[r+1];

			q = q + inco;
			r = r + 2;
		}
	}
	if (bufflag == 1)
	{
		free (cbuff);
	}
	if (incflag == 1)
	{
		free (cv2);
	}
	return 0;
}

unsigned int reverseBits(unsigned int num, unsigned int n)
{
	unsigned int  NO_OF_BITS = log(n)/log(2);	
	unsigned int reverse_num = 0, i, temp;
	for (i = 0; i < NO_OF_BITS; i++)
	{ 
		temp = (num & (1 << i));
		if(temp)
			reverse_num |= (1 << ((NO_OF_BITS - 1) - i));

	}
	/*printf("input number=%d, reversed no.=%d\n", num, reverse_num);*/
	return reverse_num;
}

int rearrange_fft( float *inp, unsigned int n)
{
	CV_COMPLEX *pfs = (CV_COMPLEX *)inp;

	int i=0, j=0;
	for (i=0; i<n; i++)
	{
		j = reverseBits(i,n);
		if (i < j)
		{
			swap(&pfs[i],&pfs[j]);
		}
	}
}

void swap(CV_COMPLEX *in, CV_COMPLEX *out)
{
	CV_COMPLEX temp;

	temp.real = out->real;
	temp.im = out->im;

	out->real = in->real;
	out->im = in->im;

	in->real = temp.real;
	in->im = temp.im;

}
/***********************************************
Functdtion name: bavfftwts

Function description: 
bavfftwts creates a vector capable of holding real or complex data.
These functions return a pointer to the newly created vector header.
The created data areas meet all padding and alignment requirements.

Parameters: 
1. pointer to pointer to vector
2. complex length 
3. real length

Return type: error integer code

************************************************/


int bavfftwts(long **p, long m, long n)
{
	volatile int k = 0,i = 0,j = 0;
	volatile float cplx_ang;
	volatile float real_ang;

	if(((*p) = (fft_vector*)calloc(1, sizeof(fft_vector))) == NULL)
	{
		printf("Hello\n");
		fprintf(stderr, "Failed to allocate memory\n");
		exit (EXIT_FAILURE);
	}
	if (n == 0)
	{
		printf("I am here 2\n:");
		if((((fft_vector*)*p)->cplx_arr = (CV_COMPLEX*)calloc((m), sizeof(CV_COMPLEX))) == NULL)
		{
			fprintf(stderr, "Failed to allocate memory for complex vector\n");
			exit (EXIT_FAILURE);
		}
		((fft_vector*)*p)->c_size = m;
		((fft_vector*)*p)->real_arr = NULL;
		
		printf("I am here 3\n:");				
		while(k < (m))
		{
			((fft_vector*)*p)->cplx_arr[j].real = cos(((2 * PI * k ) / m ));
			((fft_vector*)*p)->cplx_arr[j].im =  - sin(((2 * PI * k ) / m));
			k = k + 1;
			j += 1;
		}
	}
	else if(m == 0)
	{	
		if((((fft_vector*)*p)->real_arr = (CV_COMPLEX*)calloc((n), sizeof(CV_COMPLEX))) == NULL)
		{
			fprintf(stderr, "Failed to allocate memory for real vector\n");
			exit (EXIT_FAILURE);
		}
		((fft_vector*)*p)->r_size = n;
		((fft_vector*)*p)->cplx_arr = NULL;

		while(k < (n))
		{
			((fft_vector*)*p)->real_arr[j].real = cos(((2 * PI * k ) / n));
			((fft_vector*)*p)->real_arr[j].im =  - sin(((2 * PI * k ) / n));
			k = k + 1;
			j += 1;
		}
	}
	return (SUCCESS);
}

/***********************************************
Function name: bavfreewts

Function description: 
bavfreewts deallocates the  memory used by operand. bvfree also frees up memory allocated by 
vmalloc or vcalloc. Finally, vfree can also deallocate memory allocated by any of the FIR 
initialization functions.

Parameters: pointer to pointer to vector

Return type: error code

************************************************/


int bavfreewts(long **p)
{
	if (((fft_vector*)*p)->cplx_arr != NULL) 
	{
		free (((fft_vector*)*p)->cplx_arr);
		(((fft_vector*)*p)->cplx_arr) = NULL;
		free(((fft_vector*)*p));
		(*p) = NULL; 
	}
	else if (((fft_vector*)*p)->real_arr != NULL)
	{
		free (((fft_vector*)*p)->real_arr);
		(((fft_vector*)*p)->real_arr) = NULL;
		free(((fft_vector*)*p));
		(*p) = NULL; 
	}
	return (SUCCESS);
}


/***********************************************
Function name: bavcfftf

Function description: 
The forward complex FFT of the complex input vector is computed and stored in the complex
output vector.

Parameters: 
1. cv1 (inp) - Complex input vector
2. inc1 (inp) - Input vector increment
3. cvo (out) - Complex output vector
4. inco (inp) - Output vector increment
5. n (inp) - FFT size (number of complex points)
6. p (inp) - pointer to FFT setup previously generated by calling avfftwts

Return type: integer error code

 ***********************************************/

int bavrffti( float *cv1, long inc1, float *cout, long inco, long n, long *p) 
{
	int incflag = 0, bufflag = 0, vecflag = 0, cflag = 0;
	float *cv2;
	float *cbuff;
	int s = 0;
	int q = 0, r = 0;
	int u = 0;
	FILE *inputFd, *outputFd;

	for (u = 0; u < n*inc1; u += inc1)
	{
		int temp = 0;
		temp = cv1[u];
		cv1[u] = cv1[u+1];
		cv1[u+1] = temp;
	}
	printf("I am here\n");
	if (cv1 != cout)
	{
		bufflag = 1;
		cbuff = calloc (n*inc1, sizeof (float));
		for (s = 0; s < n*inc1; s++)
		{
			cbuff[s] = cv1[s];
		}
		
	}
	if ((inc1 != 2))
	{
		incflag = 1;
		cv2 = calloc(n*2, sizeof(float));
		while ( q < n*2 )
		{
			if (bufflag == 1)
			{
				cv2[q] = cbuff[r];
				cv2[q+1] = cbuff[r+1];
			}
			else
			{
				cv2[q] = cv1[r];
				cv2[q+1] = cv1[r+1];
			}
			q = q+2;
			r = r+inc1;
		}
		inc1 = 2;
	}
	
	cflag = 1;
	CV_COMPLEX *pfs;
	unsigned int stage,block,j,i,iw=0;
	unsigned int pa,pb,qa,qb;
	unsigned int stride,edirts;
	CV_COMPLEX ft1a,ft1b,ft2a,ft2b,ft3a,ft3b;
	unsigned int log_n;

	log_n = log(n)/log(2);

	if (incflag == 1)
		pfs = (CV_COMPLEX *)cv2;
	else if (bufflag == 1)
		pfs = (CV_COMPLEX *)cbuff;
	else
		pfs = (CV_COMPLEX *)cv1;

	CV_COMPLEX *pfw = ((fft_vector*)p)->cplx_arr;

	/*//INIT*/
	stride = n/2;
	edirts = 1;
	/*//DIF FFT*/

	for( stage=0; stage<log_n-2; stage++ ) 
	{
		for( block=0; block<n; block+=stride*2 ) 
		{
			pa = block;
			pb = block + stride/2;
			qa = block + stride;
			qb = block + stride/2 + stride;
			iw = 0;
			for( j=0; j<stride/2; j++ ) 
			{
				/*//2bufflies/loop
					//add*/
				ft1a.real = pfs[pa+j].real + pfs[qa+j].real;
				ft1a.im = pfs[pa+j].im + pfs[qa+j].im;
				ft1b.real = pfs[pb+j].real + pfs[qb+j].real;
				ft1b.im = pfs[pb+j].im + pfs[qb+j].im;
				/*//sub*/
				ft2a.real = pfs[pa+j].real - pfs[qa+j].real;
				ft2a.im = pfs[pa+j].im - pfs[qa+j].im;
				ft2b.real = pfs[pb+j].real - pfs[qb+j].real;
				ft2b.im = pfs[pb+j].im - pfs[qb+j].im;
				pfs[pa+j] = ft1a;
				/*//store adds*/
				pfs[pb+j] = ft1b;
				/*//cmul*/
				pfs[qa+j].real = ft2a.real * pfw[iw].real -
				ft2a.im * pfw[iw].im;
				pfs[qa+j].im = ft2a.real * pfw[iw].im +
				ft2a.im * pfw[iw].real;
				/*//twiddled cmul*/
				pfs[qb+j].real = ft2b.real * pfw[iw].im +
				ft2b.im * pfw[iw].real;
				pfs[qb+j].im = -ft2b.real * pfw[iw].real +
				ft2b.im * pfw[iw].im;
				iw += edirts;
			}
		}
		stride = stride>>1;
		edirts = edirts<<1;
	}
	/*//last two stages*/
	for( j=0; j<n; j+=4 ) 
	{
		/*//upper two*/
		ft1a.real = pfs[j ].real + pfs[j+2].real;
		ft1a.im = pfs[j ].im + pfs[j+2].im;
		ft1b.real = pfs[j+1].real + pfs[j+3].real;
		ft1b.im = pfs[j+1].im + pfs[j+3].im;
		ft2a.real = ft1a.real + ft1b.real;
		ft2a.im = ft1a.im + ft1b.im;
		ft2b.real = ft1a.real - ft1b.real;
		ft2b.im = ft1a.im - ft1b.im;
		/*//lower two
			//notwiddle*/
		ft3a.real = pfs[j].real - pfs[j+2].real;
		ft3a.im = pfs[j].im - pfs[j+2].im;
		/*//twiddle*/
		ft3b.real = pfs[j+1].im - pfs[j+3].im;
		ft3b.im = -pfs[j+1].real + pfs[j+3].real;
		/*//store*/
		pfs[j ]	= ft2a;
		pfs[j+1]= ft2b;
		pfs[j+2].real = ft3a.real + ft3b.real;
		pfs[j+2].im = ft3a.im + ft3b.im;
		pfs[j+3].real = ft3a.real - ft3b.real;
		pfs[j+3].im = ft3a.im - ft3b.im;
	}


	if (incflag == 1)
	{
		rearrange_fft(cv2, n);
		
		for (u = 0; u < n*2; u += 2)
		{
			int temp = 0;
			temp = cv2[u];
			cv2[u] = cv2[u+1];
			cv2[u+1] = temp;
		}

		for (u = 0; u < n*2; u += 2)
		{
			cv2[u] = cv2[u]/n;
			cv2[u+1] = cv2[u+1]/n;
		}
	
/*		outputFd = fopen("fft_temp.txt", "w+");
		for (i = 0; i < 128*1024; i++)
		{
			fprintf(outputFd, "%f\n", *((float*)cv2+i));
		}
		fclose(outputFd);
*/
	}
	
	else if (bufflag == 1)
	{
		rearrange_fft(cbuff, n);
		
		for (u = 0; u < n*2; u += 2)
		{	
			int temp = 0;
			temp = cbuff[u];
			cbuff[u] = cbuff[u+1];
			cbuff[u+1] = temp;
		}

		for (u = 0; u < n*2; u += 2)
		{
			cbuff[u] = cbuff[u]/n;
			cbuff[u+1] = cbuff[u+1]/n;
		}
		/*outputFd = fopen("fft_temp.txt", "w+");
		for (i = 0; i < 128*1024; i++)
		{
			fprintf(outputFd, "%f\n", *((float*)cbuff+i));
		}
		fclose(outputFd);*/
	}

	if ((incflag == 1) && (bufflag == 0))
	{
		q = 0;
		r = 0;
		while (r < n*2)
		{
			cv1[q] = cv2[r];
			cv1[q+1] = cv2[r+1];

			q = q + inco;
			r = r + 2;
		}
	}
	else if ((incflag == 1) && (bufflag == 1))
	{
		q = 0;
		r = 0;
		while (r < n*2)
		{
			cout[q] = cv2[r];
			//cout[q+1] = cv2[r+1];

			q = q + inco;
			r = r + 2;
		}
	}
	else if ((incflag == 0) && (bufflag == 1))
	{
		q = 0;
		r = 0;
		while (r < n*2)
		{
			cout[q] = cbuff[r];
			//cout[q+1] = cbuff[r+1];

			q = q + inco;
			r = r + 2;
		}
/*		for(i = 0; i < n*2; i++)
		{
			printf("cbuff[%d]=%f\n",i,cbuff[i]);
		}
*/
	}
	
	if (bufflag == 1)
	{
		free (cbuff);
	}
	if (incflag == 1)
	{
		free (cv2);
	}
	return 0;
}
